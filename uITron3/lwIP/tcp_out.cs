/**
 * @file
 * Transmission Control Protocol, outgoing traffic
 *
 * The output functions of TCP.
 *
 */

/*
 * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * This file is part of the lwIP TCP/IP stack.
 *
 * Author: Adam Dunkels <adam@sics.se>
 *
 */
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace uITron3
{
	public partial class tcp
	{
#if LWIP_TCP // don't build if not configured for use in lwipopts.h

		/* Define some copy-macros for checksum-on-copy so that the code looks
		   nicer by preventing too many ifdef's. */
#if TCP_CHECKSUM_ON_COPY
		public static void TCP_DATA_COPY(pointer dst, pointer src, ushort len, tcp_seg seg)
		{
			do
			{
				tcp_seg_add_chksum(lwip.LWIP_CHKSUM_COPY(dst, src, len),
					len, ref seg.chksum, ref seg.chksum_swapped);
				seg.flags |= tcp_seg.TF_SEG_DATA_CHECKSUMMED;
			} while (false);
		}

		public static void TCP_DATA_COPY2(pointer dst, pointer src, ushort len, ref ushort chksum, ref bool chksum_swapped)
		{
			tcp_seg_add_chksum(lwip.LWIP_CHKSUM_COPY(dst, src, len), len, ref chksum, ref chksum_swapped);
		}
#else // TCP_CHECKSUM_ON_COPY
		public static void TCP_DATA_COPY(pointer dst, pointer src, int len, tcp_seg seg) { opt.MEMCPY(dst, src, len); }
		public static void TCP_DATA_COPY2(pointer dst, pointer src, int len, ushort chksum, bool chksum_swapped) { opt.MEMCPY(dst, src, len); }
#endif // TCP_CHECKSUM_ON_COPY

		/** Define this to 1 for an extra check that the output checksum is valid
 * (usefule when the checksum is generated by the application, not the stack) */
#if !TCP_CHECKSUM_ON_COPY_SANITY_CHECK
		public const int TCP_CHECKSUM_ON_COPY_SANITY_CHECK = 0;
#endif

		/** Allocate a pbuf and create a tcphdr at p.payload, used for output
		 * functions other than the default tcp.tcp_output . tcp_output_segment
		 * (e.g. tcp_send_empty_ack, etc.)
		 *
		 * @param pcb tcp pcb for which to send a packet (used to initialize tcp_hdr)
		 * @param optlen length of header-options
		 * @param datalen length of tcp data to reserve in pbuf
		 * @param seqno_be seqno in network byte order (big-endian)
		 * @return pbuf with p.payload being the tcp_hdr
		 */
		private pbuf tcp_output_alloc_header(tcp_pcb pcb, ushort optlen, ushort datalen,
							  uint seqno_be /* already in network byte order */)
		{
			tcp_hdr tcphdr;
			pbuf p = lwip.pbuf_alloc(pbuf_layer.PBUF_IP, (ushort)(tcp.TCP_HLEN + optlen + datalen), pbuf_type.PBUF_RAM);
			if (p != null)
			{
				lwip.LWIP_ASSERT("check that first pbuf can hold tcp_hdr",
							 (p.len >= tcp.TCP_HLEN + optlen));
				tcphdr = new tcp_hdr(p.payload);
				tcphdr.src = lwip.lwip_htons(pcb.local_port);
				tcphdr.dest = lwip.lwip_htons(pcb.remote_port);
				tcphdr.seqno = seqno_be;
				tcphdr.ackno = lwip.lwip_htonl(pcb.rcv_nxt);
				tcp_hdr.TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), tcp.TCP_ACK);
				tcphdr.wnd = lwip.lwip_htons(pcb.rcv_ann_wnd);
				tcphdr.chksum = 0;
				tcphdr.urgp = 0;

				/* If we're sending a packet, update the announced right window edge */
				pcb.rcv_ann_right_edge = pcb.rcv_nxt + pcb.rcv_ann_wnd;
			}
			return p;
		}

		/**
		 * Called by tcp_close() to send a segment including FIN flag but not data.
		 *
		 * @param pcb the tcp_pcb over which to send a segment
		 * @return err_t.ERR_OK if sent, another err_t otherwise
		 */
		public err_t tcp_send_fin(tcp_pcb pcb)
		{
			/* first, try to add the fin to the last unsent segment */
			if (pcb.unsent != null)
			{
				tcp_seg last_unsent;
				for (last_unsent = pcb.unsent; last_unsent.next != null;
					 last_unsent = last_unsent.next)
					;

				if ((tcp_hdr.TCPH_FLAGS(last_unsent.tcphdr) & (tcp.TCP_SYN | tcp.TCP_FIN | tcp.TCP_RST)) == 0)
				{
					/* no SYN/FIN/RST flag in the header, we can add the FIN flag */
					tcp_hdr.TCPH_SET_FLAG(last_unsent.tcphdr, tcp.TCP_FIN);
					pcb.flags |= tcp_pcb.TF_FIN;
					return err_t.ERR_OK;
				}
			}
			/* no data, no length, flags, copy=1, no optdata */
			return tcp_enqueue_flags(pcb, tcp.TCP_FIN);
		}

		/**
		 * Create a TCP segment with prefilled header.
		 *
		 * Called by tcp_write and tcp_enqueue_flags.
		 *
		 * @param pcb Protocol control block for the TCP connection.
		 * @param p pbuf that is used to hold the TCP header.
		 * @param flags TCP flags for header.
		 * @param seqno TCP sequence number of this packet
		 * @param optflags options to include in TCP header
		 * @return a new tcp_seg pointing to p, or null.
		 * The TCP header is filled in except ackno and wnd.
		 * p is freed on failure.
		 */
		private tcp_seg tcp_create_segment(tcp_pcb pcb, pbuf p, byte flags, uint seqno, byte optflags)
		{
			tcp_seg seg;
			byte optlen = (byte)tcp_seg.LWIP_TCP_OPT_LENGTH(optflags);

			if ((seg = (tcp_seg)lwip.memp_malloc(memp_t.MEMP_TCP_SEG)) == null)
			{
				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 2, "tcp_create_segment: no memory.\n");
				lwip.pbuf_free(p);
				return null;
			}
			seg.flags = optflags;
			seg.next = null;
			seg.p = p;
			seg.len = (ushort)(p.tot_len - optlen);
#if TCP_OVERSIZE_DBGCHECK
			seg.oversize_left = 0;
#endif // TCP_OVERSIZE_DBGCHECK
#if TCP_CHECKSUM_ON_COPY
			seg.chksum = 0;
			seg.chksum_swapped = false;
			/* check optflags */
			lwip.LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
						(optflags & tcp_seg.TF_SEG_DATA_CHECKSUMMED) == 0);
#endif // TCP_CHECKSUM_ON_COPY

			/* build TCP header */
			if (lwip.pbuf_header(p, tcp.TCP_HLEN) != 0)
			{
				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 2, "tcp_create_segment: no room for TCP header in pbuf.\n");
				++lwip.lwip_stats.tcp.err;
				tcp_seg_free(seg);
				return null;
			}
			seg.tcphdr = new tcp_hdr(seg.p.payload);
			seg.tcphdr.src = lwip.lwip_htons(pcb.local_port);
			seg.tcphdr.dest = lwip.lwip_htons(pcb.remote_port);
			seg.tcphdr.seqno = lwip.lwip_htonl(seqno);
			/* ackno is set in tcp.tcp_output */
			tcp_hdr.TCPH_HDRLEN_FLAGS_SET(seg.tcphdr, (5 + optlen / 4), flags);
			/* wnd and chksum are set in tcp.tcp_output */
			seg.tcphdr.urgp = 0;
			return seg;
		}

		/**
		 * Allocate a pbuf_type.PBUF_RAM pbuf, perhaps with extra space at the end.
		 *
		 * This function is like lwip.pbuf_alloc(layer, length, pbuf_type.PBUF_RAM) except
		 * there may be extra bytes available at the end.
		 *
		 * @param layer flag to define header size.
		 * @param length size of the pbuf's payload.
		 * @param max_length maximum usable size of payload+oversize.
		 * @param oversize pointer to a ushort that will receive the number of usable tail bytes.
		 * @param pcb The TCP connection that willo enqueue the pbuf.
		 * @param apiflags API flags given to tcp_write.
		 * @param first_seg true when this pbuf will be used in the first enqueued segment.
		 * @param 
		 */
#if TCP_OVERSIZE
		private pbuf tcp_pbuf_prealloc(pbuf_layer layer, ushort length, ushort max_length,
						  ref ushort oversize, tcp_pcb pcb, byte apiflags,
						  byte first_seg)
		{
			pbuf p;
			ushort alloc = length;

#if LWIP_NETIF_TX_SINGLE_PBUF
			//LWIP_UNUSED_ARG(max_length);
			//LWIP_UNUSED_ARG(pcb);
			//LWIP_UNUSED_ARG(apiflags);
			//LWIP_UNUSED_ARG(first_seg);
			/* always create MSS-sized pbufs */
			alloc = max_length;
#else // LWIP_NETIF_TX_SINGLE_PBUF
			if (length < max_length)
			{
				/* Should we allocate an oversized pbuf, or just the minimum
				 * length required? If tcp_write is going to be called again
				 * before this segment is transmitted, we want the oversized
				 * buffer. If the segment will be transmitted immediately, we can
				 * save memory by allocating only length. We use a simple
				 * heuristic based on the following information:
				 *
				 * Did the user set TCP_WRITE_FLAG_MORE?
				 *
				 * Will the Nagle algorithm defer transmission of this segment?
				 */
				if ((apiflags & tcp.TCP_WRITE_FLAG_MORE) != 0 ||
					((pcb.flags & tcp_pcb.TF_NODELAY) == 0 &&
					 (first_seg == 0 ||
					  pcb.unsent != null ||
					  pcb.unacked != null)))
				{
					alloc = (ushort)Math.Min(max_length, lwip.LWIP_MEM_ALIGN_SIZE(length + opt.TCP_OVERSIZE));
				}
			}
#endif // LWIP_NETIF_TX_SINGLE_PBUF
			p = lwip.pbuf_alloc(layer, alloc, pbuf_type.PBUF_RAM);
			if (p == null)
			{
				return null;
			}
			lwip.LWIP_ASSERT("need unchained pbuf", p.next == null);
			oversize = (ushort)(p.len - length);
			/* trim p.len to the currently used size */
			p.len = p.tot_len = length;
			return p;
		}
#else // TCP_OVERSIZE
		private static pbuf tcp_pbuf_prealloc(pbuf_layer layer, ushort length, ushort mx,
			out ushort os, tcp_pcb pcb, byte api, byte fst)
		{
			os = 0;
			return lwip.pbuf_alloc(layer, length, pbuf_type.PBUF_RAM);
		}
#endif // TCP_OVERSIZE

#if TCP_CHECKSUM_ON_COPY
		/** Add a checksum of newly added data to the segment */
		static void
		tcp_seg_add_chksum(ushort chksum, ushort len, ref ushort seg_chksum,
						   ref bool seg_chksum_swapped)
		{
			uint helper;
			/* add chksum to old chksum and fold to ushort */
			helper = (uint)(chksum + seg_chksum);
			chksum = (ushort)lwip.FOLD_U32T(helper);
			if ((len & 1) != 0)
			{
				seg_chksum_swapped = !seg_chksum_swapped;
				chksum = lwip.SWAP_BYTES_IN_WORD(chksum);
			}
			seg_chksum = chksum;
		}
#endif // TCP_CHECKSUM_ON_COPY

		/** Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).
		 *
		 * @param pcb the tcp pcb to check for
		 * @param len length of data to send (checked agains snd_buf)
		 * @return err_t.ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
		 */
		private err_t tcp_write_checks(tcp_pcb pcb, ushort len)
		{
			/* connection is in invalid state for data transmission? */
			if ((pcb.state != tcp_state.ESTABLISHED) &&
				(pcb.state != tcp_state.CLOSE_WAIT) &&
				(pcb.state != tcp_state.SYN_SENT) &&
				(pcb.state != tcp_state.SYN_RCVD))
			{
				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | lwip.LWIP_DBG_STATE | lwip.LWIP_DBG_LEVEL_SEVERE, "tcp_write() called in invalid state\n");
				return err_t.ERR_CONN;
			}
			else if (len == 0)
			{
				return err_t.ERR_OK;
			}

			/* fail on too much data */
			if (len > pcb.snd_buf)
			{
				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 3, "tcp_write: too much data (len={0} > snd_buf={1})\n",
				  len, pcb.snd_buf);
				pcb.flags |= tcp_pcb.TF_NAGLEMEMERR;
				return err_t.ERR_MEM;
			}

			lwip.LWIP_DEBUGF(opt.TCP_QLEN_DEBUG, "tcp_write: queuelen: {0}\n", (ushort)pcb.snd_queuelen);

			/* If total number of pbufs on the unsent/unacked queues exceeds the
			 * configured maximum, return an error */
			/* check for configured max queuelen and possible overflow */
			if ((pcb.snd_queuelen >= opt.TCP_SND_QUEUELEN) || (pcb.snd_queuelen > tcp_pcb.TCP_SNDQUEUELEN_OVERFLOW))
			{
				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 3, "tcp_write: too long queue {0} (max {1})\n",
				  pcb.snd_queuelen, opt.TCP_SND_QUEUELEN);
				++lwip.lwip_stats.tcp.memerr;
				pcb.flags |= tcp_pcb.TF_NAGLEMEMERR;
				return err_t.ERR_MEM;
			}
			if (pcb.snd_queuelen != 0)
			{
				lwip.LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
				  pcb.unacked != null || pcb.unsent != null);
			}
			else
			{
				lwip.LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
				  pcb.unacked == null && pcb.unsent == null);
			}
			return err_t.ERR_OK;
		}

		/**
		 * Write data for sending (but does not send it immediately).
		 *
		 * It waits in the expectation of more data being sent soon (as
		 * it can send them more efficiently by combining them together).
		 * To prompt the system to send data now, call tcp.tcp_output() after
		 * calling tcp_write().
		 *
		 * @param pcb Protocol control block for the TCP connection to enqueue data for.
		 * @param arg Pointer to the data to be enqueued for sending.
		 * @param len Data length in bytes
		 * @param apiflags combination of following flags :
		 * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
		 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
		 * @return err_t.ERR_OK if enqueued, another err_t on error
		 */
		public err_t tcp_write(tcp_pcb pcb, pointer arg, ushort len, byte apiflags)
		{
			pbuf concat_p = null;
			tcp_seg last_unsent = null, seg = null, prev_seg = null, queue = null;
			ushort pos = 0; /* position in 'arg' data */
			ushort queuelen;
			byte optlen = 0;
			byte optflags = 0;
#if TCP_OVERSIZE
			ushort oversize = 0;
			ushort oversize_used = 0;
#endif // TCP_OVERSIZE
#if TCP_CHECKSUM_ON_COPY
			ushort concat_chksum = 0;
			bool concat_chksum_swapped = false;
			ushort concat_chksummed = 0;
#endif // TCP_CHECKSUM_ON_COPY
			err_t err;
			/* don't allocate segments bigger than half the maximum window we ever received */
			ushort mss_local = Math.Min(pcb.mss, (ushort)(pcb.snd_wnd_max / 2));

#if LWIP_NETIF_TX_SINGLE_PBUF
			/* Always copy to try to create single pbufs for TX */
			apiflags |= tcp.TCP_WRITE_FLAG_COPY;
#endif // LWIP_NETIF_TX_SINGLE_PBUF

			lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG, "tcp_write(pcb={0}, data={1}, len={2}, apiflags={3})\n",
			  pcb, arg, len, (ushort)apiflags);
			if (lwip.LWIP_ERROR("tcp_write: arg == null (programmer violates API)",
					   arg != null))
				return err_t.ERR_ARG;

			err = tcp_write_checks(pcb, len);
			if (err != err_t.ERR_OK)
			{
				return err;
			}
			queuelen = pcb.snd_queuelen;

#if LWIP_TCP_TIMESTAMPS
			if ((pcb.flags & tcp_pcb.TF_TIMESTAMP) != 0)
			{
				optflags = tcp_seg.TF_SEG_OPTS_TS;
				optlen = (byte)tcp_seg.LWIP_TCP_OPT_LENGTH(tcp_seg.TF_SEG_OPTS_TS);
			}
#endif // LWIP_TCP_TIMESTAMPS


			/*
			 * TCP segmentation is done in three phases with increasing complexity:
			 *
			 * 1. Copy data directly into an oversized pbuf.
			 * 2. Chain a new pbuf to the end of pcb.unsent.
			 * 3. Create new segments.
			 *
			 * We may run out of memory at any point. In that case we must
			 * return err_t.ERR_MEM and not change anything in pcb. Therefore, all
			 * changes are recorded in local variables and committed at the end
			 * of the function. Some pcb fields are maintained in local copies:
			 *
			 * queuelen = pcb.snd_queuelen
			 * oversize = pcb.unsent_oversize
			 *
			 * These variables are set consistently by the phases:
			 *
			 * seg points to the last segment tampered with.
			 *
			 * pos records progress as data is segmented.
			 */

			/* Find the tail of the unsent queue. */
			if (pcb.unsent != null)
			{
				ushort space;
				ushort unsent_optlen;

				/* @todo: this could be sped up by keeping last_unsent in the pcb */
				for (last_unsent = pcb.unsent; last_unsent.next != null;
					 last_unsent = last_unsent.next)
					;

				/* Usable space at the end of the last unsent segment */
				unsent_optlen = (ushort)tcp_seg.LWIP_TCP_OPT_LENGTH(last_unsent.flags);
				space = (ushort)(mss_local - (last_unsent.len + unsent_optlen));

				/*
				 * Phase 1: Copy data directly into an oversized pbuf.
				 *
				 * The number of bytes copied is recorded in the oversize_used
				 * variable. The actual copying is done at the bottom of the
				 * function.
				 */
#if TCP_OVERSIZE
#if TCP_OVERSIZE_DBGCHECK
				/* check that pcb.unsent_oversize matches last_unsent.unsent_oversize */
				lwip.LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
							pcb.unsent_oversize == last_unsent.oversize_left);
#endif // TCP_OVERSIZE_DBGCHECK
				oversize = pcb.unsent_oversize;
				if (oversize > 0)
				{
					lwip.LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
					seg = last_unsent;
					oversize_used = oversize < len ? oversize : len;
					pos += oversize_used;
					oversize -= oversize_used;
					space -= oversize_used;
				}
				/* now we are either finished or oversize is zero */
				lwip.LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
#endif // TCP_OVERSIZE

				/*
				 * Phase 2: Chain a new pbuf to the end of pcb.unsent.
				 *
				 * We don't extend segments containing SYN/FIN flags or options
				 * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
				 * the end.
				 */
				if ((pos < len) && (space > 0) && (last_unsent.len > 0))
				{
					ushort seglen = (ushort)(space < len - pos ? space : len - pos);
					//ushort oversize;
					//ushort concat_chksum = 0;
					//bool concat_chksum_swapped = false;
					seg = last_unsent;

					/* Create a pbuf with a copy or reference to seglen bytes. We
					 * can use pbuf_layer.PBUF_RAW here since the data appears in the middle of
					 * a segment. A header will never be prepended. */
					if ((apiflags & tcp.TCP_WRITE_FLAG_COPY) != 0)
					{
						/* Data is copied */
						if ((concat_p = tcp_pbuf_prealloc(pbuf_layer.PBUF_RAW, seglen, space, ref oversize, pcb, apiflags, 1)) == null)
						{
							lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 2,
										"tcp_write : could not allocate memory for pbuf copy size {0}\n",
										 seglen);
							goto memerr;
						}
#if TCP_OVERSIZE_DBGCHECK
						last_unsent.oversize_left += oversize;
#endif // TCP_OVERSIZE_DBGCHECK
						TCP_DATA_COPY2(concat_p.payload, arg + pos, seglen, ref concat_chksum, ref concat_chksum_swapped);
#if TCP_CHECKSUM_ON_COPY
						concat_chksummed += seglen;
#endif // TCP_CHECKSUM_ON_COPY
					}
					else
					{
						/* Data is not copied */
						if ((concat_p = lwip.pbuf_alloc(pbuf_layer.PBUF_RAW, seglen, pbuf_type.PBUF_ROM)) == null)
						{
							lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 2,
										("tcp_write: could not allocate memory for zero-copy pbuf\n"));
							goto memerr;
						}
#if TCP_CHECKSUM_ON_COPY
						/* calculate the checksum of nocopy-data */
						tcp_seg_add_chksum((ushort)~lwip.inet_chksum(arg + pos, seglen), seglen,
							ref concat_chksum, ref concat_chksum_swapped);
						concat_chksummed += seglen;
#endif // TCP_CHECKSUM_ON_COPY
						/* reference the non-volatile payload data */
						concat_p.payload = arg + pos;
					}

					pos += seglen;
					queuelen += lwip.pbuf_clen(concat_p);
				}
			}
			else
			{
#if TCP_OVERSIZE
				lwip.LWIP_ASSERT("unsent_oversize mismatch (pcb.unsent is null)",
							pcb.unsent_oversize == 0);
#endif // TCP_OVERSIZE
			}

			/*
			 * Phase 3: Create new segments.
			 *
			 * The new segments are chained together in the local 'queue'
			 * variable, ready to be appended to pcb.unsent.
			 */
			while (pos < len)
			{
				pbuf p;
				ushort left = (ushort)(len - pos);
				ushort max_len = (ushort)(mss_local - optlen);
				ushort seglen = left > max_len ? max_len : left;
				//ushort oversize;
				ushort chksum = 0;
				bool chksum_swapped = false;

				if ((apiflags & tcp.TCP_WRITE_FLAG_COPY) != 0)
				{
					/* If copy is set, memory should be allocated and data copied
					 * into pbuf */
					if ((p = tcp_pbuf_prealloc(pbuf_layer.PBUF_TRANSPORT, (ushort)(seglen + optlen), mss_local, ref oversize, pcb, apiflags, (byte)(queue == null ? 1 : 0))) == null)
					{
						lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 2, "tcp_write : could not allocate memory for pbuf copy size {0}\n", seglen);
						goto memerr;
					}
					lwip.LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
								(p.len >= seglen));
					TCP_DATA_COPY2(p.payload + optlen, arg + pos, seglen, ref chksum, ref chksum_swapped);
				}
				else
				{
					/* Copy is not set: First allocate a pbuf for holding the data.
					 * Since the referenced data is available at least until it is
					 * sent out on the link (as it has to be ACKed by the remote
					 * party) we can safely use pbuf_type.PBUF_ROM instead of pbuf_type.PBUF_REF here.
					 */
					pbuf p2;
#if TCP_OVERSIZE
					lwip.LWIP_ASSERT("oversize == 0", oversize == 0);
#endif // TCP_OVERSIZE
					if ((p2 = lwip.pbuf_alloc(pbuf_layer.PBUF_TRANSPORT, seglen, pbuf_type.PBUF_ROM)) == null)
					{
						lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 2, "tcp_write: could not allocate memory for zero-copy pbuf\n");
						goto memerr;
					}
#if TCP_CHECKSUM_ON_COPY
					/* calculate the checksum of nocopy-data */
					chksum = (ushort)~lwip.inet_chksum(arg + pos, seglen);
#endif // TCP_CHECKSUM_ON_COPY
					/* reference the non-volatile payload data */
					p2.payload = arg + pos;

					/* Second, allocate a pbuf for the headers. */
					if ((p = lwip.pbuf_alloc(pbuf_layer.PBUF_TRANSPORT, optlen, pbuf_type.PBUF_RAM)) == null)
					{
						/* If allocation fails, we have to deallocate the data pbuf as
						 * well. */
						lwip.pbuf_free(p2);
						lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 2, "tcp_write: could not allocate memory for header pbuf\n");
						goto memerr;
					}
					/* Concatenate the headers and data pbufs together. */
					lwip.pbuf_cat(p/*header*/, p2/*data*/);
				}

				queuelen += lwip.pbuf_clen(p);

				/* Now that there are more segments queued, we check again if the
				 * length of the queue exceeds the configured maximum or
				 * overflows. */
				if ((queuelen > opt.TCP_SND_QUEUELEN) || (queuelen > tcp_pcb.TCP_SNDQUEUELEN_OVERFLOW))
				{
					lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 2, "tcp_write: queue too long {0} ({1})\n", queuelen, opt.TCP_SND_QUEUELEN);
					lwip.pbuf_free(p);
					goto memerr;
				}

				if ((seg = tcp_create_segment(pcb, p, 0, pcb.snd_lbb + pos, optflags)) == null)
				{
					goto memerr;
				}
#if TCP_OVERSIZE_DBGCHECK
				seg.oversize_left = oversize;
#endif // TCP_OVERSIZE_DBGCHECK
#if TCP_CHECKSUM_ON_COPY
				seg.chksum = chksum;
				seg.chksum_swapped = chksum_swapped;
				seg.flags |= tcp_seg.TF_SEG_DATA_CHECKSUMMED;
#endif // TCP_CHECKSUM_ON_COPY

				/* first segment of to-be-queued data? */
				if (queue == null)
				{
					queue = seg;
				}
				else
				{
					/* Attach the segment to the end of the queued segments */
					lwip.LWIP_ASSERT("prev_seg != null", prev_seg != null);
					prev_seg.next = seg;
				}
				/* remember last segment of to-be-queued data for next iteration */
				prev_seg = seg;

				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | lwip.LWIP_DBG_TRACE, "tcp_write: queueing {0}:{1}\n",
				  lwip.lwip_ntohl(seg.tcphdr.seqno),
				  lwip.lwip_ntohl(seg.tcphdr.seqno) + tcp_hdr.TCP_TCPLEN(seg));

				pos += seglen;
			}

			/*
			 * All three segmentation phases were successful. We can commit the
			 * transaction.
			 */

			/*
			 * Phase 1: If data has been added to the preallocated tail of
			 * last_unsent, we update the length fields of the pbuf chain.
			 */
#if TCP_OVERSIZE
			if (oversize_used > 0)
			{
				pbuf p;
				/* Bump tot_len of whole chain, len of tail */
				for (p = last_unsent.p; p != null; p = p.next)
				{
					p.tot_len += oversize_used;
					if (p.next == null)
					{
						TCP_DATA_COPY(new pointer(p.payload.data, p.payload.offset + p.len), arg, oversize_used, last_unsent);
						p.len += oversize_used;
					}
				}
				last_unsent.len += oversize_used;
#if TCP_OVERSIZE_DBGCHECK
				lwip.LWIP_ASSERT("last_unsent.oversize_left >= oversize_used",
							last_unsent.oversize_left >= oversize_used);
				last_unsent.oversize_left -= oversize_used;
#endif // TCP_OVERSIZE_DBGCHECK
			}
			pcb.unsent_oversize = oversize;
#endif // TCP_OVERSIZE

			/*
			 * Phase 2: concat_p can be concatenated onto last_unsent.p
			 */
			if (concat_p != null)
			{
				lwip.LWIP_ASSERT("tcp_write: cannot concatenate when pcb.unsent is empty",
				  (last_unsent != null));
				lwip.pbuf_cat(last_unsent.p, concat_p);
				last_unsent.len += concat_p.tot_len;
#if TCP_CHECKSUM_ON_COPY
				if (concat_chksummed != 0)
				{
					tcp_seg_add_chksum(concat_chksum, concat_chksummed, ref last_unsent.chksum,
					  ref last_unsent.chksum_swapped);
					last_unsent.flags |= tcp_seg.TF_SEG_DATA_CHECKSUMMED;
				}
#endif // TCP_CHECKSUM_ON_COPY
			}

			/*
			 * Phase 3: Append queue to pcb.unsent. Queue may be null, but that
			 * is harmless
			 */
			if (last_unsent == null)
			{
				pcb.unsent = queue;
			}
			else
			{
				last_unsent.next = queue;
			}

			/*
			 * Finally update the pcb state.
			 */
			pcb.snd_lbb += len;
			pcb.snd_buf -= len;
			pcb.snd_queuelen = queuelen;

			lwip.LWIP_DEBUGF(opt.TCP_QLEN_DEBUG, "tcp_write: {0} (after enqueued)\n",
			  pcb.snd_queuelen);
			if (pcb.snd_queuelen != 0)
			{
				lwip.LWIP_ASSERT("tcp_write: valid queue length",
							pcb.unacked != null || pcb.unsent != null);
			}

			/* Set the PSH flag in the last segment that we enqueued. */
			if (seg != null && seg.tcphdr != null && ((apiflags & tcp.TCP_WRITE_FLAG_MORE) == 0))
			{
				tcp_hdr.TCPH_SET_FLAG(seg.tcphdr, tcp.TCP_PSH);
			}

			return err_t.ERR_OK;
		memerr:
			pcb.flags |= tcp_pcb.TF_NAGLEMEMERR;
			++lwip.lwip_stats.tcp.memerr;

			if (concat_p != null)
			{
				lwip.pbuf_free(concat_p);
			}
			if (queue != null)
			{
				tcp_segs_free(queue);
			}
			if (pcb.snd_queuelen != 0)
			{
				lwip.LWIP_ASSERT("tcp_write: valid queue length", pcb.unacked != null ||
				  pcb.unsent != null);
			}
			lwip.LWIP_DEBUGF(opt.TCP_QLEN_DEBUG | lwip.LWIP_DBG_STATE, "tcp_write: {0} (with mem err)\n", pcb.snd_queuelen);
			return err_t.ERR_MEM;
		}

		/**
		 * Enqueue TCP options for transmission.
		 *
		 * Called by tcp_connect(), tcp_listen_input(), and tcp_send_ctrl().
		 *
		 * @param pcb Protocol control block for the TCP connection.
		 * @param flags TCP header flags to set in the outgoing segment.
		 * @param optdata pointer to TCP options, or null.
		 * @param optlen length of TCP options in bytes.
		 */
		public err_t tcp_enqueue_flags(tcp_pcb pcb, byte flags)
		{
			pbuf p;
			tcp_seg seg;
			byte optflags = 0;
			byte optlen = 0;

			lwip.LWIP_DEBUGF(opt.TCP_QLEN_DEBUG, "tcp_enqueue_flags: queuelen: {0}\n", (ushort)pcb.snd_queuelen);

			lwip.LWIP_ASSERT("tcp_enqueue_flags: need either tcp.TCP_SYN or tcp.TCP_FIN in flags (programmer violates API)",
						(flags & (tcp.TCP_SYN | tcp.TCP_FIN)) != 0);

			/* check for configured max queuelen and possible overflow */
			if ((pcb.snd_queuelen >= opt.TCP_SND_QUEUELEN) || (pcb.snd_queuelen > tcp_pcb.TCP_SNDQUEUELEN_OVERFLOW))
			{
				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 3, "tcp_enqueue_flags: too long queue {0} (max {1})\n",
												   pcb.snd_queuelen, opt.TCP_SND_QUEUELEN);
				++lwip.lwip_stats.tcp.memerr;
				pcb.flags |= tcp_pcb.TF_NAGLEMEMERR;
				return err_t.ERR_MEM;
			}

			if ((flags & tcp.TCP_SYN) != 0)
			{
				optflags = tcp_seg.TF_SEG_OPTS_MSS;
			}
#if LWIP_TCP_TIMESTAMPS
			if ((pcb.flags & tcp_pcb.TF_TIMESTAMP) != 0)
			{
				optflags |= tcp_seg.TF_SEG_OPTS_TS;
			}
#endif // LWIP_TCP_TIMESTAMPS
			optlen = (byte)tcp_seg.LWIP_TCP_OPT_LENGTH(optflags);

			/* tcp_enqueue_flags is always called with either SYN or FIN in flags.
			 * We need one available snd_buf byte to do that.
			 * This means we can't send FIN while snd_buf==0. A better fix would be to
			 * not include SYN and FIN sequence numbers in the snd_buf count. */
			if (pcb.snd_buf == 0)
			{
				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | 3, "tcp_enqueue_flags: no send buffer available\n");
				++lwip.lwip_stats.tcp.memerr;
				return err_t.ERR_MEM;
			}

			/* Allocate pbuf with room for TCP header + options */
			if ((p = lwip.pbuf_alloc(pbuf_layer.PBUF_TRANSPORT, optlen, pbuf_type.PBUF_RAM)) == null)
			{
				pcb.flags |= tcp_pcb.TF_NAGLEMEMERR;
				++lwip.lwip_stats.tcp.memerr;
				return err_t.ERR_MEM;
			}
			lwip.LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
						(p.len >= optlen));

			/* Allocate memory for tcp_seg, and fill in fields. */
			if ((seg = tcp_create_segment(pcb, p, flags, pcb.snd_lbb, optflags)) == null)
			{
				pcb.flags |= tcp_pcb.TF_NAGLEMEMERR;
				++lwip.lwip_stats.tcp.memerr;
				return err_t.ERR_MEM;
			}
			lwip.LWIP_ASSERT("seg.tcphdr not aligned", (seg.tcphdr.offset % opt.MEM_ALIGNMENT) == 0);
			lwip.LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg.len == 0);

			lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG | lwip.LWIP_DBG_TRACE,
						"tcp_enqueue_flags: queueing {0}:{1} (0x{2:X})\n",
						 lwip.lwip_ntohl(seg.tcphdr.seqno),
						 lwip.lwip_ntohl(seg.tcphdr.seqno) + tcp_hdr.TCP_TCPLEN(seg),
						 (ushort)flags);

			/* Now append seg to pcb.unsent queue */
			if (pcb.unsent == null)
			{
				pcb.unsent = seg;
			}
			else
			{
				tcp_seg useg;
				for (useg = pcb.unsent; useg.next != null; useg = useg.next) ;
				useg.next = seg;
			}
#if TCP_OVERSIZE
			/* The new unsent tail has no space */
			pcb.unsent_oversize = 0;
#endif // TCP_OVERSIZE

			/* SYN and FIN bump the sequence number */
			if ((flags & tcp.TCP_SYN) != 0 || (flags & tcp.TCP_FIN) != 0)
			{
				pcb.snd_lbb++;
				/* optlen does not influence snd_buf */
				pcb.snd_buf--;
			}
			if ((flags & tcp.TCP_FIN) != 0)
			{
				pcb.flags |= tcp_pcb.TF_FIN;
			}

			/* update number of segments on the queues */
			pcb.snd_queuelen += lwip.pbuf_clen(seg.p);
			lwip.LWIP_DEBUGF(opt.TCP_QLEN_DEBUG, "tcp_enqueue_flags: {0} (after enqueued)\n", pcb.snd_queuelen);
			if (pcb.snd_queuelen != 0)
			{
				lwip.LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
				  pcb.unacked != null || pcb.unsent != null);
			}

			return err_t.ERR_OK;
		}

#if LWIP_TCP_TIMESTAMPS
		/* Build a timestamp option (12 bytes long) at the specified options pointer)
		 *
		 * @param pcb tcp_pcb
		 * @param opts option pointer where to store the timestamp option
		 */
		private static void tcp_build_timestamp_option(tcp_pcb pcb, pointer opts)
		{
			/* Pad with two NOP options to make everything nicely aligned */
			opts.SetValue((uint)lwip.PP_HTONL(0x0101080A));
			opts += sizeof(uint);
			opts.SetValue((uint)lwip.lwip_htonl((uint)sys.sys_now()));
			opts += sizeof(uint);
			opts.SetValue((uint)lwip.lwip_htonl(pcb.ts_recent));
		}
#endif

		/** Send an ACK without data.
		 *
		 * @param pcb Protocol control block for the TCP connection to send the ACK
		 */
		public err_t tcp_send_empty_ack(tcp_pcb pcb)
		{
			pbuf p;
			tcp_hdr tcphdr;
			byte optlen = 0;

#if LWIP_TCP_TIMESTAMPS
			if ((pcb.flags & tcp_pcb.TF_TIMESTAMP) != 0)
			{
				optlen = (byte)tcp_seg.LWIP_TCP_OPT_LENGTH(tcp_seg.TF_SEG_OPTS_TS);
			}
#endif

			p = tcp_output_alloc_header(pcb, optlen, 0, lwip.lwip_htonl(pcb.snd_nxt));
			if (p == null)
			{
				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG, "tcp_output: (ACK) could not allocate pbuf\n");
				return err_t.ERR_BUF;
			}
			tcphdr = new tcp_hdr(p.payload);
			lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG,
						"tcp_output: sending ACK for {0}\n", pcb.rcv_nxt);
			/* remove ACK flags from the PCB, as we send an empty ACK now */
			pcb.flags &= unchecked((byte)~(tcp_pcb.TF_ACK_DELAY | tcp_pcb.TF_ACK_NOW));

			/* NB. MSS option is only sent on SYNs, so ignore it here */
#if LWIP_TCP_TIMESTAMPS
			pcb.ts_lastacksent = pcb.rcv_nxt;

			if ((pcb.flags & tcp_pcb.TF_TIMESTAMP) != 0)
			{
				tcp_build_timestamp_option(pcb, new pointer(tcphdr.data, tcphdr.offset + tcp_hdr.length));
			}
#endif

#if CHECKSUM_GEN_TCP
			tcphdr.chksum = lwip.inet_chksum_pseudo(p, pcb.local_ip, pcb.remote_ip,
				  ip.IP_PROTO_TCP, p.tot_len);
#endif
#if LWIP_NETIF_HWADDRHINT
			lwip.ip.ip_output_hinted(p, pcb.local_ip, pcb.remote_ip, pcb.ttl, pcb.tos,
				ip.IP_PROTO_TCP, pcb.addr_hint);
#else // LWIP_NETIF_HWADDRHINT
			ip.ip_output(p, pcb.local_ip, pcb.remote_ip, pcb.ttl, pcb.tos,
				ip.IP_PROTO_TCP);
#endif // LWIP_NETIF_HWADDRHINT
			lwip.pbuf_free(p);

			return err_t.ERR_OK;
		}

		/**
		 * Find out what we can send and send it
		 *
		 * @param pcb Protocol control block for the TCP connection to send data
		 * @return err_t.ERR_OK if data has been sent or nothing to send
		 *         another err_t on error
		 */
		public err_t tcp_output(tcp_pcb pcb)
		{
			tcp_seg seg, useg;
			uint wnd, snd_nxt;
#if TCP_CWND_DEBUG
			short i = 0;
#endif // TCP_CWND_DEBUG

			/* pcb.state tcp_state.LISTEN not allowed here */
			lwip.LWIP_ASSERT("don't call tcp.tcp_output for listen-pcbs",
			  pcb.state != tcp_state.LISTEN);

			/* First, check if we are invoked by the TCP input processing
			   code. If so, we do not output anything. Instead, we rely on the
			   input processing code to call us when input processing is done
			   with. */
			if (lwip.tcp.tcp_input_pcb == pcb)
			{
				return err_t.ERR_OK;
			}

			wnd = Math.Min(pcb.snd_wnd, pcb.cwnd);

			seg = pcb.unsent;

			/* If the tcp_pcb.TF_ACK_NOW flag is set and no data will be sent (either
			 * because the .unsent queue is empty or because the window does
			 * not allow it), construct an empty ACK segment and send it.
			 *
			 * If data is to be sent, we will just piggyback the ACK (see below).
			 */
			if ((pcb.flags & tcp_pcb.TF_ACK_NOW) != 0 &&
			   (seg == null ||
				lwip.lwip_ntohl(seg.tcphdr.seqno) - pcb.lastack + seg.len > wnd))
			{
				return tcp_send_empty_ack(pcb);
			}

			/* useg should point to last segment on unacked queue */
			useg = pcb.unacked;
			if (useg != null)
			{
				for (; useg.next != null; useg = useg.next) ;
			}

#if TCP_OUTPUT_DEBUG
			if (seg == null)
			{
				lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG, "tcp_output: nothing to send ({0})\n",
											   pcb.unsent);
			}
#endif // TCP_OUTPUT_DEBUG
#if TCP_CWND_DEBUG
			if (seg == null)
			{
				lwip.LWIP_DEBUGF(opt.TCP_CWND_DEBUG, "tcp_output: snd_wnd {0}"
											 + ", cwnd {1}, wnd {2}"
											 + ", seg == null, ack {3}\n",
											 pcb.snd_wnd, pcb.cwnd, wnd, pcb.lastack);
			}
			else
			{
				lwip.LWIP_DEBUGF(opt.TCP_CWND_DEBUG,
							"tcp_output: snd_wnd {0}, cwnd {1}, wnd {2}"
							 + ", effwnd {3}, seq {4}, ack {5}\n",
							 pcb.snd_wnd, pcb.cwnd, wnd,
							 lwip.lwip_ntohl(seg.tcphdr.seqno) - pcb.lastack + seg.len,
							 lwip.lwip_ntohl(seg.tcphdr.seqno), pcb.lastack);
			}
#endif // TCP_CWND_DEBUG
			/* data available and window allows it to be sent? */
			while (seg != null &&
				   lwip.lwip_ntohl(seg.tcphdr.seqno) - pcb.lastack + seg.len <= wnd)
			{
				lwip.LWIP_ASSERT("RST not expected here!",
							(tcp_hdr.TCPH_FLAGS(seg.tcphdr) & tcp.TCP_RST) == 0);
				/* Stop sending if the nagle algorithm would prevent it
				 * Don't stop:
				 * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
				 * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
				 *   either seg.next != null or pcb.unacked == null;
				 *   RST is no sent using tcp_write/tcp.tcp_output.
				 */
				if (!tcp.tcp_do_output_nagle(pcb) &&
				  ((pcb.flags & (tcp_pcb.TF_NAGLEMEMERR | tcp_pcb.TF_FIN)) == 0))
				{
					break;
				}
#if TCP_CWND_DEBUG
				lwip.LWIP_DEBUGF(opt.TCP_CWND_DEBUG, "tcp_output: snd_wnd {0}, cwnd {1}, wnd {2}, effwnd {3}, seq {4}, ack {5}, i {6}\n",
										pcb.snd_wnd, pcb.cwnd, wnd,
										lwip.lwip_ntohl(seg.tcphdr.seqno) + seg.len -
										pcb.lastack,
										lwip.lwip_ntohl(seg.tcphdr.seqno), pcb.lastack, i);
				++i;
#endif // TCP_CWND_DEBUG

				pcb.unsent = seg.next;

				if (pcb.state != tcp_state.SYN_SENT)
				{
					tcp_hdr.TCPH_SET_FLAG(seg.tcphdr, tcp.TCP_ACK);
					pcb.flags &= unchecked((byte)~(tcp_pcb.TF_ACK_DELAY | tcp_pcb.TF_ACK_NOW));
				}

				tcp_output_segment(seg, pcb);
				snd_nxt = lwip.lwip_ntohl(seg.tcphdr.seqno) + (uint)tcp_hdr.TCP_TCPLEN(seg);
				if (tcp.TCP_SEQ_LT(pcb.snd_nxt, snd_nxt))
				{
					pcb.snd_nxt = snd_nxt;
				}
				/* put segment on unacknowledged list if length > 0 */
				if (tcp_hdr.TCP_TCPLEN(seg) > 0)
				{
					seg.next = null;
					/* unacked list is empty? */
					if (pcb.unacked == null)
					{
						pcb.unacked = seg;
						useg = seg;
						/* unacked list is not empty? */
					}
					else
					{
						/* In the case of fast retransmit, the packet should not go to the tail
						 * of the unacked queue, but rather somewhere before it. We need to check for
						 * this case. -STJ Jul 27, 2004 */
						if (tcp.TCP_SEQ_LT(lwip.lwip_ntohl(seg.tcphdr.seqno), lwip.lwip_ntohl(useg.tcphdr.seqno)))
						{
							/* add segment to before tail of unacked list, keeping the list sorted */
							tcp_seg cur_seg = pcb.unacked;
							while (cur_seg != null &&
							  tcp.TCP_SEQ_LT(lwip.lwip_ntohl((cur_seg).tcphdr.seqno), lwip.lwip_ntohl(seg.tcphdr.seqno)))
							{
								cur_seg = cur_seg.next;
							}
							seg.next = (cur_seg);
							(cur_seg) = seg;
						}
						else
						{
							/* add segment to tail of unacked list */
							useg.next = seg;
							useg = useg.next;
						}
					}
					/* do not queue empty segments on the unacked list */
				}
				else
				{
					tcp_seg_free(seg);
				}
				seg = pcb.unsent;
			}
#if TCP_OVERSIZE
			if (pcb.unsent == null)
			{
				/* last unsent has been removed, reset unsent_oversize */
				pcb.unsent_oversize = 0;
			}
#endif // TCP_OVERSIZE

			pcb.flags &= unchecked((byte)~tcp_pcb.TF_NAGLEMEMERR);
			return err_t.ERR_OK;
		}

		/**
		 * Called by tcp.tcp_output() to actually send a TCP segment over IP.
		 *
		 * @param seg the tcp_seg to send
		 * @param pcb the tcp_pcb for the TCP connection used to send the segment
		 */
		private void tcp_output_segment(tcp_seg seg, tcp_pcb pcb)
		{
			ushort len;
			pointer opts;

			/** @bug Exclude retransmitted segments from this count. */
			//snmp.snmp_inc_tcpoutsegs();

			/* The TCP header has already been constructed, but the ackno and
			 wnd fields remain. */
			seg.tcphdr.ackno = lwip.lwip_htonl(pcb.rcv_nxt);

			/* advertise our receive window size in this TCP segment */
			seg.tcphdr.wnd = lwip.lwip_htons(pcb.rcv_ann_wnd);

			pcb.rcv_ann_right_edge = pcb.rcv_nxt + pcb.rcv_ann_wnd;

			/* Add any requested options.  NB MSS option is only set on SYN
			   packets, so ignore it here */
			opts = new pointer(seg.tcphdr.data, seg.tcphdr.offset + tcp_hdr.length);
			if ((seg.flags & tcp_seg.TF_SEG_OPTS_MSS) != 0)
			{
				ushort mss;
#if TCP_CALCULATE_EFF_SEND_MSS
				mss = tcp_eff_send_mss(opt.TCP_MSS, pcb.remote_ip);
#else // TCP_CALCULATE_EFF_SEND_MSS
				mss = opt.TCP_MSS;
#endif // TCP_CALCULATE_EFF_SEND_MSS
				opts.SetValue(tcp_seg.TCP_BUILD_MSS_OPTION(mss));
				opts += 1;
			}
#if LWIP_TCP_TIMESTAMPS
			pcb.ts_lastacksent = pcb.rcv_nxt;

			if ((seg.flags & tcp_seg.TF_SEG_OPTS_TS) != 0)
			{
				tcp_build_timestamp_option(pcb, /*opts*/new pointer(seg.tcphdr.data, seg.tcphdr.offset + 1));
				opts += 3;
			}
#endif

			/* Set retransmission timer running if it is not currently enabled 
			   This must be set before checking the route. */
			if (pcb.rtime == -1)
			{
				pcb.rtime = 0;
			}

			/* If we don't have a local IP address, we get one by
			   calling ip.ip_route(). */
			if (ip_addr.ip_addr_isany(pcb.local_ip))
			{
				ip_addr.ip_addr_copy(pcb.local_ip, lwip.ip.ip_addr);
			}

			if (pcb.rttest == 0)
			{
				pcb.rttest = tcp_ticks;
				pcb.rtseq = lwip.lwip_ntohl(seg.tcphdr.seqno);

				lwip.LWIP_DEBUGF(opt.TCP_RTO_DEBUG, "tcp_output_segment: rtseq {0}\n", pcb.rtseq);
			}
			lwip.LWIP_DEBUGF(opt.TCP_OUTPUT_DEBUG, "tcp_output_segment: {0}:{1}\n",
					lwip.lwip_htonl(seg.tcphdr.seqno), lwip.lwip_htonl(seg.tcphdr.seqno) +
					seg.len);

			len = (ushort)(seg.tcphdr - seg.p.payload);

			seg.p.len -= len;
			seg.p.tot_len -= len;

			seg.p.payload = seg.tcphdr;

			seg.tcphdr.chksum = 0;
#if CHECKSUM_GEN_TCP
#if TCP_CHECKSUM_ON_COPY
			{
				uint acc;
#if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
				ushort chksum_slow = lwip.inet_chksum_pseudo(seg.p, pcb.local_ip,
					   pcb.remote_ip, ip.IP_PROTO_TCP, seg.p.tot_len);
#endif // TCP_CHECKSUM_ON_COPY_SANITY_CHECK
				if ((seg.flags & tcp_seg.TF_SEG_DATA_CHECKSUMMED) == 0)
				{
					lwip.LWIP_ASSERT("data included but not checksummed",
					  seg.p.tot_len == (tcp_hdr.TCPH_HDRLEN(seg.tcphdr) * 4));
				}

				/* rebuild TCP header checksum (TCP header changes for retransmissions!) */
				acc = lwip.inet_chksum_pseudo_partial(seg.p, pcb.local_ip,
						 pcb.remote_ip,
						 ip.IP_PROTO_TCP, seg.p.tot_len, (ushort)(tcp_hdr.TCPH_HDRLEN(seg.tcphdr) * 4));
				/* add payload checksum */
				if (seg.chksum_swapped)
				{
					seg.chksum = lwip.SWAP_BYTES_IN_WORD(seg.chksum);
					seg.chksum_swapped = false;
				}
				acc += (ushort)~(seg.chksum);
				seg.tcphdr.chksum = (ushort)lwip.FOLD_U32T(acc);
#if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
				if (chksum_slow != seg.tcphdr.chksum)
				{
					lwip.LWIP_DEBUGF(opt.TCP_DEBUG | lwip.LWIP_DBG_LEVEL_WARNING,
								"tcp_output_segment: calculated checksum is {0} instead of {1:X}\n",
								seg.tcphdr.chksum, chksum_slow);
					seg.tcphdr.chksum = chksum_slow;
				}
#endif // TCP_CHECKSUM_ON_COPY_SANITY_CHECK
			}
#else // TCP_CHECKSUM_ON_COPY 
			seg.tcphdr.chksum = lwip.inet_chksum_pseudo(seg.p, pcb.local_ip,
				pcb.remote_ip,
				ip.IP_PROTO_TCP, seg.p.tot_len);
#endif // TCP_CHECKSUM_ON_COPY
#endif // CHECKSUM_GEN_TCP
			++lwip.lwip_stats.tcp.xmit;

#if LWIP_NETIF_HWADDRHINT
			lwip.ip.ip_output_hinted(seg.p, pcb.local_ip, pcb.remote_ip, pcb.ttl, pcb.tos,
				ip.IP_PROTO_TCP, pcb.addr_hint);
#else // LWIP_NETIF_HWADDRHINT
			ip.ip_output(seg.p, pcb.local_ip, pcb.remote_ip, pcb.ttl, pcb.tos,
				ip.IP_PROTO_TCP);
#endif // LWIP_NETIF_HWADDRHINT
		}

		/**
		 * Send a TCP RESET packet (empty segment with RST flag set) either to
		 * abort a connection or to show that there is no matching local connection
		 * for a received segment.
		 *
		 * Called by tcp.tcp_abort() (to abort a local connection), tcp_input() (if no
		 * matching local pcb was found), tcp_listen_input() (if incoming segment
		 * has ACK flag set) and tcp_process() (received segment in the wrong state)
		 *
		 * Since a RST segment is in most cases not sent for an active connection,
		 * tcp_rst() has a number of arguments that are taken from a tcp_pcb for
		 * most other segment output functions.
		 *
		 * @param seqno the sequence number to use for the outgoing segment
		 * @param ackno the acknowledge number to use for the outgoing segment
		 * @param local_ip the local IP address to send the segment from
		 * @param remote_ip the remote IP address to send the segment to
		 * @param local_port the local TCP port to send the segment from
		 * @param remote_port the remote TCP port to send the segment to
		 */
		public void tcp_rst(uint seqno, uint ackno,
		  ip_addr local_ip, ip_addr remote_ip,
		  ushort local_port, ushort remote_port)
		{
			pbuf p;
			tcp_hdr tcphdr;
			p = lwip.pbuf_alloc(pbuf_layer.PBUF_IP, tcp.TCP_HLEN, pbuf_type.PBUF_RAM);
			if (p == null)
			{
				lwip.LWIP_DEBUGF(opt.TCP_DEBUG, "tcp_rst: could not allocate memory for pbuf\n");
				return;
			}
			lwip.LWIP_ASSERT("check that first pbuf can hold tcp_hdr",
						(p.len >= tcp_hdr.length));

			tcphdr = new tcp_hdr(p.payload);
			tcphdr.src = lwip.lwip_htons(local_port);
			tcphdr.dest = lwip.lwip_htons(remote_port);
			tcphdr.seqno = lwip.lwip_htonl(seqno);
			tcphdr.ackno = lwip.lwip_htonl(ackno);
			tcp_hdr.TCPH_HDRLEN_FLAGS_SET(tcphdr, tcp.TCP_HLEN / 4, tcp.TCP_RST | tcp.TCP_ACK);
			tcphdr.wnd = lwip.PP_HTONS(opt.TCP_WND);
			tcphdr.chksum = 0;
			tcphdr.urgp = 0;

#if CHECKSUM_GEN_TCP
			tcphdr.chksum = lwip.inet_chksum_pseudo(p, local_ip, remote_ip,
				ip.IP_PROTO_TCP, p.tot_len);
#endif
			++lwip.lwip_stats.tcp.xmit;
			//snmp.snmp_inc_tcpoutrsts();
			/* Send output with hardcoded TTL since we have no access to the pcb */
			lwip.ip.ip_output(p, local_ip, remote_ip, opt.TCP_TTL, 0, ip.IP_PROTO_TCP);
			lwip.pbuf_free(p);
			lwip.LWIP_DEBUGF(opt.TCP_RST_DEBUG, "tcp_rst: seqno {0} ackno {1}.\n", seqno, ackno);
		}

		/**
		 * Requeue all unacked segments for retransmission
		 *
		 * Called by tcp_slowtmr() for slow retransmission.
		 *
		 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
		 */
		public void tcp_rexmit_rto(tcp_pcb pcb)
		{
			tcp_seg seg;

			if (pcb.unacked == null)
			{
				return;
			}

			/* Move all unacked segments to the head of the unsent queue */
			for (seg = pcb.unacked; seg.next != null; seg = seg.next) ;
			/* concatenate unsent queue after unacked queue */
			seg.next = pcb.unsent;
			/* unsent queue is the concatenated queue (of unacked, unsent) */
			pcb.unsent = pcb.unacked;
			/* unacked queue is now empty */
			pcb.unacked = null;
			/* last unsent hasn't changed, no need to reset unsent_oversize */

			/* increment number of retransmissions */
			++pcb.nrtx;

			/* Don't take any RTT measurements after retransmitting. */
			pcb.rttest = 0;

			/* Do the actual retransmission */
			tcp_output(pcb);
		}

		/**
		 * Requeue the first unacked segment for retransmission
		 *
		 * Called by tcp_receive() for fast retramsmit.
		 *
		 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
		 */
		public static void tcp_rexmit(tcp_pcb pcb)
		{
			tcp_seg seg;
			tcp_seg cur_seg;

			if (pcb.unacked == null)
			{
				return;
			}

			/* Move the first unacked segment to the unsent queue */
			/* Keep the unsent queue sorted. */
			seg = pcb.unacked;
			pcb.unacked = seg.next;

			cur_seg = pcb.unsent;
			while (cur_seg != null &&
			  tcp.TCP_SEQ_LT(lwip.lwip_ntohl((cur_seg).tcphdr.seqno), lwip.lwip_ntohl(seg.tcphdr.seqno)))
			{
				cur_seg = cur_seg.next;
			}
			seg.next = cur_seg;
			cur_seg = seg;
#if TCP_OVERSIZE
			if (seg.next == null)
			{
				/* the retransmitted segment is last in unsent, so reset unsent_oversize */
				pcb.unsent_oversize = 0;
			}
#endif // TCP_OVERSIZE

			++pcb.nrtx;

			/* Don't take any rtt measurements after retransmitting. */
			pcb.rttest = 0;

			/* Do the actual retransmission. */
			//snmp.snmp_inc_tcpretranssegs();
			/* No need to call tcp.tcp_output: we are always called from tcp_input()
			   and thus tcp.tcp_output directly returns. */
		}


		/**
		 * Handle retransmission after three dupacks received
		 *
		 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
		 */
		public static void tcp_rexmit_fast(tcp_pcb pcb)
		{
			if (pcb.unacked != null && (pcb.flags & tcp_pcb.TF_INFR) == 0)
			{
				/* This is fast retransmit. Retransmit the first unacked segment. */
				lwip.LWIP_DEBUGF(opt.TCP_FR_DEBUG,
							"tcp_receive: dupacks {0} ({1}"
							 + "), fast retransmit {2}\n",
							 (ushort)pcb.dupacks, pcb.lastack,
							 lwip.lwip_ntohl(pcb.unacked.tcphdr.seqno));
				tcp_rexmit(pcb);

				/* Set ssthresh to half of the minimum of the current
				 * cwnd and the advertised window */
				if (pcb.cwnd > pcb.snd_wnd)
				{
					pcb.ssthresh = (ushort)(pcb.snd_wnd / 2);
				}
				else
				{
					pcb.ssthresh = (ushort)(pcb.cwnd / 2);
				}

				/* The minimum value for ssthresh should be 2 MSS */
				if (pcb.ssthresh < 2 * pcb.mss)
				{
					lwip.LWIP_DEBUGF(opt.TCP_FR_DEBUG,
								"tcp_receive: The minimum value for ssthresh {0}"
								 + " should be min 2 mss {1}...\n",
								 pcb.ssthresh, 2 * pcb.mss);
					pcb.ssthresh = (ushort)(2 * pcb.mss);
				}

				pcb.cwnd = (ushort)(pcb.ssthresh + 3 * pcb.mss);
				pcb.flags |= tcp_pcb.TF_INFR;
			}
		}


		/**
		 * Send keepalive packets to keep a connection active although
		 * no data is sent over it.
		 *
		 * Called by tcp_slowtmr()
		 *
		 * @param pcb the tcp_pcb for which to send a keepalive packet
		 */
		public void tcp_keepalive(tcp_pcb pcb)
		{
			pbuf p;
			tcp_hdr tcphdr;

			lwip.LWIP_DEBUGF(opt.TCP_DEBUG, "tcp_keepalive: sending KEEPALIVE probe to {0}.{1}.{2}.{3}\n",
									ip_addr.ip4_addr1_16(pcb.remote_ip), ip_addr.ip4_addr2_16(pcb.remote_ip),
									ip_addr.ip4_addr3_16(pcb.remote_ip), ip_addr.ip4_addr4_16(pcb.remote_ip));

			lwip.LWIP_DEBUGF(opt.TCP_DEBUG, "tcp_keepalive: tcp_ticks {0}   pcb.tmr {1} pcb.keep_cnt_sent {2}\n",
									tcp_ticks, pcb.tmr, pcb.keep_cnt_sent);

			p = tcp_output_alloc_header(pcb, 0, 0, lwip.lwip_htonl(pcb.snd_nxt - 1));
			if (p == null)
			{
				lwip.LWIP_DEBUGF(opt.TCP_DEBUG,
							("tcp_keepalive: could not allocate memory for pbuf\n"));
				return;
			}
			tcphdr = new tcp_hdr(p.payload);

#if CHECKSUM_GEN_TCP
			tcphdr.chksum = lwip.inet_chksum_pseudo(p, pcb.local_ip, pcb.remote_ip,
												ip.IP_PROTO_TCP, p.tot_len);
#endif
			++lwip.lwip_stats.tcp.xmit;

			/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
			lwip.ip.ip_output_hinted(p, pcb.local_ip, pcb.remote_ip, pcb.ttl, 0, ip.IP_PROTO_TCP,
				pcb.addr_hint);
#else // LWIP_NETIF_HWADDRHINT
			ip.ip_output(p, pcb.local_ip, pcb.remote_ip, pcb.ttl, 0, ip.IP_PROTO_TCP);
#endif // LWIP_NETIF_HWADDRHINT

			lwip.pbuf_free(p);

			lwip.LWIP_DEBUGF(opt.TCP_DEBUG, "tcp_keepalive: seqno {0} ackno {1}.\n",
									pcb.snd_nxt - 1, pcb.rcv_nxt);
		}


		/**
		 * Send persist timer zero-window probes to keep a connection active
		 * when a window update is lost.
		 *
		 * Called by tcp_slowtmr()
		 *
		 * @param pcb the tcp_pcb for which to send a zero-window probe packet
		 */
		public void tcp_zero_window_probe(tcp_pcb pcb)
		{
			pbuf p;
			tcp_hdr tcphdr;
			tcp_seg seg;
			ushort len;
			byte is_fin;

			lwip.LWIP_DEBUGF(opt.TCP_DEBUG,
						"tcp_zero_window_probe: sending ZERO WINDOW probe to "
						 + "{0}.{1}.{2}.{3}\n",
						 ip_addr.ip4_addr1_16(pcb.remote_ip), ip_addr.ip4_addr2_16(pcb.remote_ip),
						 ip_addr.ip4_addr3_16(pcb.remote_ip), ip_addr.ip4_addr4_16(pcb.remote_ip));

			lwip.LWIP_DEBUGF(opt.TCP_DEBUG,
						"tcp_zero_window_probe: tcp_ticks "
						+ "{0}   pcb.tmr {1} pcb.keep_cnt_sent {2}\n",
						tcp_ticks, pcb.tmr, pcb.keep_cnt_sent);

			seg = pcb.unacked;

			if (seg == null)
			{
				seg = pcb.unsent;
			}
			if (seg == null)
			{
				return;
			}

			is_fin = (((tcp_hdr.TCPH_FLAGS(seg.tcphdr) & tcp.TCP_FIN) != 0) && (seg.len == 0)) ? (byte)1 : (byte)0;
			/* we want to send one seqno: either FIN or data (no options) */
			len = is_fin != 0 ? (ushort)0 : (ushort)1;

			p = tcp_output_alloc_header(pcb, 0, len, seg.tcphdr.seqno);
			if (p == null)
			{
				lwip.LWIP_DEBUGF(opt.TCP_DEBUG, "tcp_zero_window_probe: no memory for pbuf\n");
				return;
			}
			tcphdr = new tcp_hdr(p.payload);

			if (is_fin != 0)
			{
				/* FIN segment, no data */
				tcp_hdr.TCPH_FLAGS_SET(tcphdr, tcp.TCP_ACK | tcp.TCP_FIN);
			}
			else
			{
				/* Data segment, copy in one byte from the head of the unacked queue */
				pointer d = p.payload + tcp.TCP_HLEN;
				/* Depending on whether the segment has already been sent (unacked) or not
				   (unsent), seg.p.payload points to the IP header or TCP header.
				   Ensure we copy the first TCP data byte: */
				lwip.pbuf_copy_partial(seg.p, d, 1, (ushort)(seg.p.tot_len - seg.len));
			}

#if CHECKSUM_GEN_TCP
			tcphdr.chksum = lwip.inet_chksum_pseudo(p, pcb.local_ip, pcb.remote_ip,
												ip.IP_PROTO_TCP, p.tot_len);
#endif
			++lwip.lwip_stats.tcp.xmit;

			/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
			lwip.ip.ip_output_hinted(p, pcb.local_ip, pcb.remote_ip, pcb.ttl, 0, ip.IP_PROTO_TCP,
				pcb.addr_hint);
#else // LWIP_NETIF_HWADDRHINT
			ip.ip_output(p, pcb.local_ip, pcb.remote_ip, pcb.ttl, 0, ip.IP_PROTO_TCP);
#endif // LWIP_NETIF_HWADDRHINT

			lwip.pbuf_free(p);

			lwip.LWIP_DEBUGF(opt.TCP_DEBUG, "tcp_zero_window_probe: seqno {0}"
									+ " ackno {1}.\n",
									pcb.snd_nxt - 1, pcb.rcv_nxt);
		}
#endif // LWIP_TCP
	}
}
